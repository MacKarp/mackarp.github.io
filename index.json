[{"content":"Rust Action RPG Tutorial jest portem świetnego tutoriala stworzonego przez HeartBeast, gdzie pokazuje jak stworzyć prostą grę rpg przy użyciu silnika Godot.\nZałożenia Niedługo przed rozpoczęciem prac nad tym projektem zainteresowałem się językiem 🦀 Rust 🦀, który mnie oczarował od samego początku. Po przerobieniu podstaw stwierdziłem że trzeba się wziąć za cos większego - zawsze mi lepiej nauka programowania wychodziła na większych projektach, gdzie musiałem sam znaleźć rozwiązanie problemu(chociażby podstawowego) niż przerabianie książek czy innych źródeł gdzie autor tłumaczy koncepcje języka lub jego składnie. W tym samym czasie jakoś przypadkiem trafiłem na parę filmików dotyczących silnika Godot na kanale Gamefromscratch i postanowiłem połączyć naukę dwóch rzeczy jednocześnie.\nRezultat Bazując na świetnym tutorialu odtworzyłem cały kod w Rust przy wykorzystaniu biblioteki gdnative w trakcie pracy okazało się że w bibliotece brakuje 2 metod dla Vector2 więc je wysłałem na upstream:\n Vector2 move_towards po kilku poprawkach zostało dodane 😁 Vector2 normalized zostało zamknięte, pomysł nie przeszedł bo biblioteka, na której bazuje Vector2 posiada już funkcję normalizującą, jedyna różnica między moją wersją a wersją z biblioteki jest taka że moja w przypadku Vectora2 o parametrach 0.0 0.0 zwraca Vector2 o parametrach 0.0 0.0 (tak zachowuje się funkcja w silniku Godot) natomiast funkcja z biblioteki w przypadku Vectora2 o takich parametrach zwraca do silnika wartość: NaN NaN - wewnętrznie następuje dzielenie przez 0. Autorzy biblioteki stwierdzili że developer powinien sam decydować co w takim przypadku zrobić.  Podsumowanie Świetnie się bawiłem przy tym projekcie, wiele się nauczyłem i kto wie może w przyszłości zrobię jeszcze jakąś prostą grę 🙂\nRepozytorium kodu Repozytorium projektu znajduje sie na moim GitHubie.\n","permalink":"https://www.karpinski.tech/projekty/05.rust_action_rpg/","summary":"Rust Action RPG Tutorial jest portem świetnego tutoriala stworzonego przez HeartBeast, gdzie pokazuje jak stworzyć prostą grę rpg przy użyciu silnika Godot.\nZałożenia Niedługo przed rozpoczęciem prac nad tym projektem zainteresowałem się językiem 🦀 Rust 🦀, który mnie oczarował od samego początku. Po przerobieniu podstaw stwierdziłem że trzeba się wziąć za cos większego - zawsze mi lepiej nauka programowania wychodziła na większych projektach, gdzie musiałem sam znaleźć rozwiązanie problemu(chociażby podstawowego) niż przerabianie książek czy innych źródeł gdzie autor tłumaczy koncepcje języka lub jego składnie.","title":"Rust Action RPG"},{"content":"Cookbook jest aplikacją webową i desktopową umożliwiającą przeglądanie, wyszukiwanie i zapisywanie przepisów na dania i koktajle. Celem projektu było zaprojektowanie i zbudowanie aplikacji, które będą konsumowały zewnętrzne API i synchronizowały między sobą stan użytkownika. Dodatkowym kryterium miało być zastosowanie poznanych wzorców projektowych i jak największe pokrycie kodu testami. Aplikacja desktopowa miała być natywna, było zakazane wykorzystanie technologii WebView (żeby nie robić wrappera aplikacji webowej). Aplikacje wykonane na laboratorium z przedmiotu \u0026ldquo;Zaawansowane metody programowania\u0026rdquo; w semestrze letnim 2020/2021.\nPodział prac Nad projektem aplikacji pracowała dwu osobowa grupa. Skład i podział prac wyglądał następująco:\n Karpiński Maciej:  Aplikacja desktopowa DevOps; Backend Firebase.   Kuczma Łukasz:  Aplikacja webowa Backend Firebase.    Opis funkcjonalny System realizuje następujące funkcjonalności:\n Aplikacja desktopowa  Aplikacja dla systemu Windows, Aplikacja dla systemu Linux, Logowanie przy pomocy e-maila, Logowanie przy pomocy Google, Logowanie przy pomocy Facebooka, Przeglądanie przepisów na posiłki, Przeglądanie przepisów na koktajle, Dodawanie i usuwanie ulubionych przepisów na posiłki, Dodawanie i usuwanie ulubionych przepisów na koktajle, Synchronizacja z bazą danych Cloud Firestore.   Aplikacja webowa  Przeglądanie przepisów posiłków,  Wyszukiwanie posiłków po nazwie Wyszukiwanie posiłków po kategorii Wyszukiwanie posiłków po regionie świata Wyszukiwanie posiłków po składnikach   Logowanie przy pomocy e-maila, Logowania przy pomocy konta Google, Logowanie przy pomocy konta Facebook, Dodawanie i usuwanie przepisów do/z ulubionych, Synchronizacja między aplikacjami, Obsługa zewnętrznych API z przepisami posiłków, Obsługa bazy danych Cloud Firestore    Interfejs Interfejs aplikacji został zaprojektowany przy użyciu narzędzia Glade. Aplikacja w systemie Linux podąża za ustawionym motywem w systemie. W Windowsie występuje jedynie motyw adwaita. Aplikacja po uruchomieniu wygląda następująco:\nStack technologiczny aplikacji desktopowej Aplikacja desktopowa została stworzona przy wykorzystaniu następujących technologii:\n chrono firestore-db-and-auth Glade Google Firebase gtk GTK+ 3 oauth2 open rand reqwest Rust serde url Visual studio code  Podsumowanie Przed rozpoczęciem pracy nad aplikacją poznałem język programowania 🦀 Rust 🦀, który oczarował mnie od samego początku. Wcześniej pisałem różne większe i mniejsze aplikacji w różnych językach, ale zawsze mi w każdym coś nie pasowało aż do czasu gdy poznałem Rust, który mnie oczarował od samego początku, bawiłem się nim trochę, ale połączenie pracy i studiów nie pozwalało mi zrobić czegoś większego, ten projekt pozwolił mi poznać dobrze ten język i jak w przypadku innych języków nie zniechęcił mnie do siebie. Każdy, kto kiedyś programował w Rustcie wie, że borrow checker się czepia, ale jak tylko udało mi się go \u0026ldquo;pokonać\u0026rdquo; 🤣 wszystko, co zaprogramowałem działało a jeśli nadal był jakiś problem to był on natury logicznej jak np. nieprawidłowe wywołanie API albo wywołanie funkcji w nieprawidłowej kolejności niż jakieś wiszące wskaźniki czy nieprawidłowe argumenty przekazane do funkcji. Tworzenie aplikacji było mniejszym wyzwaniem niż początkowo się wydawało, praca nad projektem bardzo rozwinęła moją znajomość tego języka programowania. Brak oficjalnego SDK do API Google Firebase i słabo rozwinięte niektóre biblioteki stworzone przez użytkowników sprawiały niekiedy problemy, przez co musiałem część funkcjonalności stworzyć samemu, kod odpowiedzialny za OAuth2 po zakończeniu projektu rozwinąłem i udostępniłem bibliotece, z którą pracowałem. Wybór technologii GTK do stworzenia interfejsu użytkownika był nowym i interesującym doświadczeniem, jedynymi problemami okazała się słaba dokumentacja dotycząca kompilacji aplikacji dla systemu Windows, oraz niekompatybilność biblioteki WebKit (o czym w czasie wyboru technologii nie wiedziałem) z systemem Windows, przez co jedna z zaplanowanych funkcjonaliści nie działa do końca jak chciałem, ale obszedłem to w inny sposób, który ostatecznie okazał się lepszy (zamiast otwierać ekran logowania przez WebView, otwierałem przeglądarkę i nasłuchiwałem odpowiedzi zwrotnej). Tworząc aplikacje nauczyłem się wielu rzeczy takich jak cross kompilacja, autoryzacja OAuth2, obsługa Google Firebase, Travis CI czy wykorzystanie zewnętrznego API w aplikacji dekstopowej.\nRepozytorium kodu Repozytorium projektu znajduje sie na moim GitHubie. Można tam również pobrać aplikację desktopową.\nAplikacja webowa dostępna jest tu\n","permalink":"https://www.karpinski.tech/projekty/04.cookbook/","summary":"Cookbook jest aplikacją webową i desktopową umożliwiającą przeglądanie, wyszukiwanie i zapisywanie przepisów na dania i koktajle. Celem projektu było zaprojektowanie i zbudowanie aplikacji, które będą konsumowały zewnętrzne API i synchronizowały między sobą stan użytkownika. Dodatkowym kryterium miało być zastosowanie poznanych wzorców projektowych i jak największe pokrycie kodu testami. Aplikacja desktopowa miała być natywna, było zakazane wykorzystanie technologii WebView (żeby nie robić wrappera aplikacji webowej). Aplikacje wykonane na laboratorium z przedmiotu \u0026ldquo;Zaawansowane metody programowania\u0026rdquo; w semestrze letnim 2020/2021.","title":"Cookbook"},{"content":"HotScrew jest mobilną aplikacją, umożliwiającą robotom znalezienie swojej drugiej połówki i umówienie się z nią na randkę przy pomocy wbudowanego czatu. Wzorem przy projektowaniu i programowaniu była aplikacja Tinder. HotScrew dostępna jest na smartfony z systemem operacyjnym Android. Zastosowana technologia umożliwia przy niewielkiej modyfikacji zbudowanie działającej aplikacji na smartfony z systemem iOS lub aplikacji webowej. Aplikacja wykonana na laboratorium z przedmiotu \u0026ldquo;Programowanie aplikacji mobilnych\u0026rdquo; w semestrze zimowym 2021/2022.\nPodział prac Nad projektem aplikacji pracowała czteroosobowa grupa. Skład i podział prac wyglądał następująco:\n Karpiński Maciej:  Project Manager DevOps; Implementacja backendu aplikacji; Backend AWS Amplify.   Krysa Marcin:  Backend AWS Amplify; Implementacja backendu aplikacji; Implementacja czatu.   Kuczma Łukasz:  Projekt graficzny makiet; System dopasowań; Implementacja frontendu aplikacji.   Mertuszka Adam:  Implementacja frontendu aplikacji; Implementacja czatu; System dopasowań.    Ale jak to powszechnie wiadomo w pracach grupowych jeden robi więcej, drugi mniej. W tym wypadku większość pracy wykonałem samodzielnie, zostawiając chłopakom czas nad pracę nad aplikacją Lodovka, gdzie to oni wykonali większość roboty 🙂\nOpis funkcjonalny Aplikacja HotScrew realizuje następne funkcjonalności:\n Rejestracja i logowanie przy pomocy e-maila; Logowanie przy pomocy konta Facebooka; Logowanie przy pomocy konta Google; Personalizacja profilu; Przeglądanie dopasowanych profilów; Polubienie i odrzucenie profilu; Czat między dopasowanymi profilami; Obsługa AWS Amplify; Aplikacja działająca na systemie operacyjnym Android.  Interfejs Makiety interfejsu aplikacji został zaprojektowane w aplikacji Figma.\nBazując na zaprojektowanych makietach udało się stworzyć następujący interfejs aplikacji:\nEkrany odpowiedzialne za logowanie, rejestrację i resetowanie hasła zostały wygenerowane automatycznie przez SDK AWS, niestety ze względu na brak czasu nie został od dopasowany do pozostałej części funkcjonalności.\nBackend Aplikacja wykorzystuje AWS Amplify a w szczególności poniższe części:\n Amplify DataStore Amazon Cognito Amazon S3  Po zakończeniu projektu backend aplikacji został wyłączony aby nie generował niepotrzebnych kosztów.\nStack technologiczny W projekcie wykorzystany zostały następujące technologie:\n Amazon Cognito Identity SDK for JavaScript Android Studio AWS Amplify AWS Amplify React Native Core Asynciterator Polyfill Expo Expo AV Expo ImagePicker Expo Linking Expo React Native ActionSheet Feather icons InAppBrowser for React Native Node.js NPM React React Native React Native Async Storage React Native Community React Native Emoji Selector React Native Gesture Handler React Native Image Picker React Native Permissions React Native Picker React Native Picker Select React Native Reanimated React Native SafeAreaContext React Native VectorIcons uuidv4 Visual Studio Code  Podsumowanie Projekt aplikacji mobilnej był bardzo ciekawy, choć nie jest to pierwsza aplikacja mobilna, którą robiłem była ona zdecydowanie najbardziej rozbudowana. Największym wyzwaniem okazało się wykorzystanie języka JavaScript, mimo że znak kilka innych języków to sprawiał mi on trochę problemu. Jestem zdecydowanie zwolennikiem języków statycznie typowanych, znacznie ułatwia mi to pisanie i debugowanie kodu - kompilator Rusta mnie chyba za bardzo rozpieścił 😅. Oczywiście zamiast JavaScripta mogłem wykorzystać TypeScripta ale duża część różnego rodzaju tutoriali do ReactNative była pisana z uwzględnieniem JS więc i tego się trzymałem. Zdecydowanym zaskoczeniem było dla mnie gdy w czasie prezentacji funkcjonalności czatu działał on bezproblemowo, wcześniej podczas testów zdarzało się że wiadomości przychodziły ze sporym opóźnieniem i często w dosyć losowej kolejności, mimo że w bazie danych były one prawidłowo zapisane. Czy bym jeszcze z własnej nieprzymuszonej woli wybrał ReactNative i JS do pisania kolejne aplikacji mobilne? Odpowiedź brzmi: Zdecydowanie nie, takie połączenie jest dla mnie zbyt pokręcone 🤣, zdecydowanie lepiej wspominam aplikacje, które kiedyś pisałem w Javie.\nNazwa HotScrew jest \u0026ldquo;lekko\u0026rdquo; kontrowersyjna, zupełnie przypadkowo 😅 wymyśliłem sobie \u0026ldquo;Gorącą śrubkę\u0026rdquo; i tak też to przetłumaczyłem i zgłosiłem podczas pierwszego etapu projektu\u0026hellip; dopiero później zostałem uświadomiony że jest w niej drugie dno 🤣 na szczęście wszystko obyło się bez afery a i jak później się okazało \u0026ldquo;Śrubka\u0026rdquo; została zapamiętana i dzięki niej zaliczyłem laboratorium z przedmiotu Programowanie dla inżynierów na magisterce 😁\nRepozytorium kodu Repozytorium projektu znajduje się na moim GitHubie\n","permalink":"https://www.karpinski.tech/projekty/03.hotscrew/","summary":"HotScrew jest mobilną aplikacją, umożliwiającą robotom znalezienie swojej drugiej połówki i umówienie się z nią na randkę przy pomocy wbudowanego czatu. Wzorem przy projektowaniu i programowaniu była aplikacja Tinder. HotScrew dostępna jest na smartfony z systemem operacyjnym Android. Zastosowana technologia umożliwia przy niewielkiej modyfikacji zbudowanie działającej aplikacji na smartfony z systemem iOS lub aplikacji webowej. Aplikacja wykonana na laboratorium z przedmiotu \u0026ldquo;Programowanie aplikacji mobilnych\u0026rdquo; w semestrze zimowym 2021/2022.\nPodział prac Nad projektem aplikacji pracowała czteroosobowa grupa.","title":"HotScrew - Klon Tindera dla robotów!"},{"content":"Projekt domowego serwera chodził mi po głowie już od dłuższego czasu, ale z różnych powodów ciągle go odkładałem na później. Projekt w końcu zrealizowałem w 2021/2022 na potrzeby pracy dyplomowej, której celem była budowa domowego serwera multimediów i plików. Promotorem pracy był dr inż. Zbigniew Fryźlewicz.\nWymagania pracy dyplomowej:\n System operacyjny: Linux Serwer multimediów (strumieniowanie muzyki/filmów) Serwer e-booków Serwer plików z możliwością konwersji audio i wideo  Hardware Chciałem, żeby urządzenie było w miarę kompaktowe i energooszczędne, więc początkowo rozglądałem się za płytami głównymi w formacie mini i nano ITX, ale wtedy trafiłem na kilka artykułów i filmów przedstawiających realizację podobnych projektów na RaspberryPi. Wcześniej nie miałem okazji „pobawić” się SBC – zawsze uważałem je za gadżet więc i nie wiedziałem jak bardzo pod względem możliwości rozwinęła się ta część IT. Wybór SBC powodował, że jednocześnie miałem załatwioną kwestię niskiego zużycia energii i zachowania kompaktowych wymiarów, z drugiej strony SBC często wykorzystują procesory o architekturze ARM a ta poza telefonami z androidem była dla mnie zupełnie nieznana. Zmiana architektury nie byłaby dla mnie minus a wręcz plusem, w końcu mógłbym zrobić coś nowego niż złożenie kolejnego zestawu na x86-64, poprzedni raz taką zmianę w architekturze dokonałem w okolicach 2000r gdzie przesiadłem się z Amigi 600 na PC. Dużym minusem wszystkich SBC, jakie oglądałem była mała liczba (max 2) lub całkowity brak portów SATA, co uniemożliwiało utworzenie sensownej macierzy dyskowej, a którą mimo braku w wymaganiach chciałem mieć. Szukając informacji jak sensownie podłączyć (nie przez USB!) większą ilość dysków trafiłem na SBC RockPi4 i nakładki Quad i Penta SATA Kit, obie nakładki pozwalają na podłączenie 4 dysków(5 w przypadku Penta) co już pozwala na utworzenie macierzy RAID 5, a to już mnie zadowalało. Kolejnym elementem był wybór twardych dysków, chciałem, żeby były to dyski 2,5” i żeby cena za 1GB była jak najmniejsza. Wybór padł więc na dedykowane dla systemów NAS dyski WD Red Plus o pojemności 1TB z myślą o przyszłej wymianie na pojemniejsze dyski SSD – gdy ich ceny będą korzystniejsze.\nDo realizacji projektu wybrałem:\n Rock Pi 4 Model A z 4GB RAM Penta SATA KIT Moduł eMMC 64GB 4x NAS WD Red™ Plus 2,5” WD10JFCX  Software Wymagania pracy były dosyć jasne wystarczyło więc tylko dobrać odpowiednie oprogramowanie. Do realizacji wykorzystałem:\n Armbian Buster Docker Jellyfin Calibre Nextcloud + Collabora + wtyczki do konwersji wideo i bazującej na niej audio  Kontenery zostały utworzone na podstawie konfiguracji dostępnych w repozytorium\nMontaż Po otrzymaniu wszystkich zamówionych podzespołów zabrałem się za montaż, który przebiegł bez – jak początkowo myślałem – najmniejszego problemu. Na etapie konfiguracji systemu operacyjnego okazało się, że nie działa wyświetlacz w TOP HAT, po zbadaniu sprawy wyszło, że dołączony został nieprawidłowy kabelek łączący SATA HAT i TOP HAT (Tematy 1 i 2), który przepalił wyświetlacz po otrzymaniu prawidłowego kabelka i nowej TOP HAT wszystko zadziałało.\nKonfiguracja systemu operacyjnego System Armbian został zainstalowany na module eMMC, na dyskach HDD utworzyłem macierz RAIDZ – odpowiednik RAID 5 z systemem plików ZFS. Trochę czasu zajęło mi odpowiednie doszlifowanie plików z konfiguracją dla Docker Compose, skonfigurowanie wszystkich aplikacji na potrzeby prezentacji pracy i zabezpieczenie serwera gdzie pomocny był artykuł How to Secure A Web Server i książka Unix i Linux Przewodnik administratora systemów. Po zabezpieczeniu utworzyłem w moim routerze TP-Link przekierowania na odpowiednie porty i ustawiłem domenę DDNS. Jedynie czego mi brakowało to uruchomienie szyfrowania SSL w usługach, szukając informacji jak najlepiej to zrobić i kilka nieudanych prób spowodowało, że musiałem pomysł zarzucić — połączenie pracy zawodowej, zbliżającego się terminu oddania pracy dyplomowej i realizacja projektu na zaliczenie przedmiotu Programowanie urządzeń mobilnych sprawiło, że nie miałem już więcej czasu na doszlifowanie tego brakującego elementu (jak się później okazało, to było bardzo łatwe i szybkie do realizacji!).\nObronę pracy dyplomowej zaliczyłem na 5!🥳\nDalsze losy serwera Po obronie pracy dyplomowej zgodnie z zaleceniem promotora serwer w obecnej konfiguracji pracował jeszcze 3 miesiące, po których upływie zaorałem wszystko. Debian, na którym bazował Armbian choć stabilny to jednak posiada starszą wersję pakietów, chciałem czegoś „nowszego”. Bazując na różnych źródłach próbowałem uruchomić Fedora Server, ale niestety po paru dniach walk nie udało mi się, przywróciłem kopię Armbiana na eMMC i uruchomiłem jedynie kontener z Nextcloud. Mając wolny czas szukałem informacji jak uruchomić szyfrowanie SSL i testując różne rozwiązania w końcu trafiłem na projekt Nginx Proxy Manager! Po jego uruchomieniu jako kontener dockerowy wystarczy tylko go skonfigurować i zmienić parę opcji w ustawieniach kontenera Nextcloud a wszystkie problemy z SSL jakie miałem same się rozwiązały! Proste i skuteczne rozwiązanie, przy którym spędziłem jeden wieczór. Kolejnym kontenerem, jaki dodałem, a na który trafiłem zupełnie przypadkiem jest Portainer co bardzo ułatwia mi życie przy zarządzaniu 😄\nPrzygoda z snapshotami ZFS Wszystko działało pięknie, ale po jakimś czasie zauważyłem, że mam coraz mniej dostępnego miejsca na serwerku z 3TB zostało niecałe 150GB, postanowiłem trochę posprzątać – myśląc, że pewnie automatyczne kopie kilku moich PC zaszalały i spuchły 😉, jakie było moje zdziwienie, gdy po usunięciu niektórych danych ilość wolnego miejsca jeszcze zmalała! Badając temat znalazłem przyczynę, moja macierz ZFS ma ponad 13000 snapshotów! Po krótkiej konsultacji na Reedicie (Tematy 1 i 2) zrobiłem odpowiednią konfiguracje i prostym skrypcikiem udało mi się temat ogarnąć 😄 najwyraźniej moje zabawy sprawiły, że docker sobie potworzył wiele zbędnych snapshotów pożerając całe miejsce 😄\nDalsze plany Chciałbym zmigrować swoją instancję Nextcloud na kontener AIO oraz dodać do niego Proton Bridge, aby przekonfigurować wysyłkę maili z gmaila na moją domenę w proton mail.\n","permalink":"https://www.karpinski.tech/projekty/02.serwer/","summary":"Projekt domowego serwera chodził mi po głowie już od dłuższego czasu, ale z różnych powodów ciągle go odkładałem na później. Projekt w końcu zrealizowałem w 2021/2022 na potrzeby pracy dyplomowej, której celem była budowa domowego serwera multimediów i plików. Promotorem pracy był dr inż. Zbigniew Fryźlewicz.\nWymagania pracy dyplomowej:\n System operacyjny: Linux Serwer multimediów (strumieniowanie muzyki/filmów) Serwer e-booków Serwer plików z możliwością konwersji audio i wideo  Hardware Chciałem, żeby urządzenie było w miarę kompaktowe i energooszczędne, więc początkowo rozglądałem się za płytami głównymi w formacie mini i nano ITX, ale wtedy trafiłem na kilka artykułów i filmów przedstawiających realizację podobnych projektów na RaspberryPi.","title":"Domowy serwerk"},{"content":"Prosta strona stworzona przy użyciu Hugo i motywu PaperMod w celu zebrania w jednym miejscu informacji na temat projektów, w których brałem udział.\n","permalink":"https://www.karpinski.tech/projekty/01.strona_www/","summary":"Prosta strona stworzona przy użyciu Hugo i motywu PaperMod w celu zebrania w jednym miejscu informacji na temat projektów, w których brałem udział.","title":"Strona WWW"}]